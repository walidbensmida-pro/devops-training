# Fiche de rÃ©vision : SÃ©curitÃ© applicative moderne

ðŸ“‘ **Sommaire**
1. [Concepts clÃ©s](#concepts-clÃ©s)
2. [DÃ©finitions rapides](#dÃ©finitions-rapides)
3. [Exemples concrets](#exemples-concrets)
4. [Tableau : Attaques courantes & parades](#tableau--attaques-courantes--parades)
5. [Astuces entretien](#astuces-entretien)
6. [Quiz rapide](#quiz-rapide)
7. [Questions dâ€™entretien & cas pratiques](#questions-dentretien--cas-pratiques)
8. [RÃ©ponses types (synthÃ©tiques)](#rÃ©ponses-types-synthÃ©tiques)
9. [RÃ©ponse type Ã  la question : "Comment sÃ©curiser une application en microservices ?"](#rÃ©ponse-type-Ã -la-question--comment-sÃ©curiser-une-application-en-microservices-)
    - [1. MÃ©thodologie globale](#1-mÃ©thodologie-globale)
    - [2. Ã‰tapes et bonnes pratiques](#2-Ã©tapes-et-bonnes-pratiques)
    - [3. Technologies et protocoles recommandÃ©s](#3-technologies-et-protocoles-recommandÃ©s)
    - [4. SchÃ©ma mermaid : chaÃ®ne de sÃ©curitÃ© microservices](#4-schÃ©ma-mermaid--chaÃ®ne-de-sÃ©curitÃ©-microservices)
    - [5. Astuces entretien](#5-astuces-entretien)
10. [RÃ©ponse simple et dÃ©butant Ã  : "Comment sÃ©curiser une application en microservices ?"](#rÃ©ponse-simple-et-dÃ©butant-Ã --comment-sÃ©curiser-une-application-en-microservices-)
    - [Ã‰tapes claires Ã  lâ€™oral (niveau dÃ©butant)](#Ã©tapes-claires-Ã -loral-niveau-dÃ©butant)
    - [Exemple de rÃ©ponse orale (dÃ©butant)](#exemple-de-rÃ©ponse-orale-dÃ©butant)
    - [Astuce entretien](#astuce-entretien)
11. [Exemple d'Ã©tapes concrÃ¨tes pour sÃ©curiser une appli microservices Spring Boot (dÃ©butant)](#exemple-dÃ©tapes-concrÃ¨tes-pour-sÃ©curiser-une-appli-microservices-spring-boot-dÃ©butant)
    - [RÃ©sumÃ© oral](#rÃ©sumÃ©-oral)

---


## Concepts clÃ©s

- Authentification (login, JWT, OAuth2, OpenID Connect)
- Autorisation (RBAC, ABAC)
- SÃ©curitÃ© API (CORS, rate limiting, input validation)
- Gestion des secrets (Vault, KMS, .env)
- SÃ©curitÃ© CI/CD (scans, secrets, dÃ©pendances)
- SÃ©curitÃ© cloud (IAM, policies, audit)

### DÃ©finitions rapides

- **Authentification** : prouver l'identitÃ© d'un utilisateur (login/mot de passe, SSO, MFA).
- **Autorisation** : vÃ©rifier les droits d'accÃ¨s (RBAC = rÃ´les, ABAC = attributs).
- **JWT** : token signÃ© contenant les claims d'identitÃ© et d'autorisation.
- **OAuth2/OpenID Connect** : dÃ©lÃ©gation d'authentification/autorisation (SSO, login Google, etc.).
- **CORS** : contrÃ´le des accÃ¨s cross-domain cÃ´tÃ© navigateur.
- **Rate limiting** : limiter le nombre de requÃªtes pour Ã©viter les abus.
- **Input validation** : filtrer/sÃ©curiser les entrÃ©es utilisateur (contre XSS, injection SQL, etc.).
- **Vault/KMS** : gestion centralisÃ©e et sÃ©curisÃ©e des secrets.
- **IAM** : gestion des identitÃ©s et accÃ¨s dans le cloud.

---

## Exemples concrets

### Authentification JWT avec Spring Security

```java
// Configuration d'un filtre JWT
public class JwtFilter extends OncePerRequestFilter {
  @Override
  protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
      throws ServletException, IOException {
    String token = req.getHeader("Authorization");
    if (token != null && validate(token)) {
      // Authentifier l'utilisateur dans le contexte Spring
    }
    chain.doFilter(req, res);
  }
}
```

### ProtÃ©ger une API avec OAuth2 (Spring Boot)

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: https://auth-server/.well-known/jwks.json
```

### CORS (Spring Boot)

```java
// Autoriser CORS sur un contrÃ´leur
@CrossOrigin(origins = "https://mon-frontend.com")
@RestController
public class ApiController { ... }
```

### Input validation (Java)

```java
// Validation d'entrÃ©e avec Bean Validation
public class UserDto {
  @NotBlank
  @Email
  private String email;
}
```

### Gestion des secrets (Vault CLI)

```bash
vault kv put secret/app password=supersecret
vault kv get secret/app
```

### IAM Cloud (exemple GCP)

```yaml
bindings:
- role: roles/storage.objectViewer
  members:
    - user:dev@exemple.com
```

### Scan CI/CD (GitHub Actions)

```yaml
- name: Scan dÃ©pendances
  uses: actions/dependency-review-action@v3
```

---

## Tableau : Attaques courantes & parades

| Attaque         | Impact                  | Parade principale                  |
|-----------------|------------------------|------------------------------------|
| Injection SQL   | AccÃ¨s/altÃ©ration BDD   | RequÃªtes prÃ©parÃ©es, validation     |
| XSS             | Vol de session, deface | Ã‰chapper les sorties, CSP, validation |
| CSRF            | Action non voulue      | Token CSRF, SameSite cookie        |
| Brute force     | Compromission compte   | Limiter tentatives, CAPTCHA, MFA   |
| Exposition secret| Fuite dâ€™info sensible | Stockage sÃ©curisÃ©, audit, rotation |

---

## Astuces entretien

- Savoir expliquer la diffÃ©rence authentification/autorisation.
- Citer des bonnes pratiques sÃ©curitÃ© API :
  - Valider/saniter toutes les entrÃ©es.
  - Utiliser HTTPS partout.
  - Limiter les droits (principe du moindre privilÃ¨ge).
  - Stocker les secrets hors du code (Vault, KMS, variables d'env).
  - Activer le logging et l'audit.
  - Mettre Ã  jour les dÃ©pendances (scans SCA).
- Savoir oÃ¹ stocker un secret en prod : Vault, KMS, Secret Manager, jamais dans le code ou le repo.

---

## Quiz rapide

- Quâ€™est-ce quâ€™un JWT ?
  - Un token signÃ© contenant des informations d'identitÃ© et d'autorisation.
- Comment protÃ©ger une API contre lâ€™injection SQL ?
  - Utiliser des requÃªtes prÃ©parÃ©es/ORM, valider les entrÃ©es.
- OÃ¹ stocker un mot de passe dâ€™application ?
  - Dans un gestionnaire de secrets (Vault, KMS, Secret Manager), jamais en dur dans le code.

---

## Questions dâ€™entretien & cas pratiques

- **DiffÃ©rence authentification vs autorisation ?**
- **Citer 3 attaques courantes sur une API.**
- **Comment sÃ©curiser un pipeline CI/CD ?**
- **Expliquer le principe du moindre privilÃ¨ge.**
- **Comment gÃ©rer les secrets dans un cluster Kubernetes ?**
- **Donner un exemple de validation dâ€™entrÃ©e cÃ´tÃ© backend.**
- **Comment dÃ©tecter une faille XSS ?**
- **Comment fonctionne OAuth2 ?**
- **Pourquoi utiliser HTTPS ?**
- **Comment auditer les accÃ¨s Ã  une API ?**

---

## RÃ©ponses types (synthÃ©tiques)

- **Authentification** : prouver l'identitÃ©, ex : login/mot de passe.
- **Autorisation** : vÃ©rifier les droits, ex : accÃ¨s admin.
- **Attaques courantes** : injection SQL, XSS, brute force, CSRF.
- **SÃ©curiser CI/CD** : scanner les dÃ©pendances, stocker secrets hors du code, limiter les droits des runners.
- **Moindre privilÃ¨ge** : donner le minimum de droits nÃ©cessaires.
- **Secrets K8s** : utiliser Secret K8s, Vault, RBAC restrictif.
- **Validation dâ€™entrÃ©e** : regex, type, taille, whitelist.
- **DÃ©tecter XSS** : scanner le code, tester lâ€™injection de scripts.
- **OAuth2** : dÃ©lÃ©gation dâ€™authentification/autorisation via un provider externe.
- **HTTPS** : chiffrer les Ã©changes, garantir lâ€™intÃ©gritÃ© et lâ€™authenticitÃ©.
- **Audit API** : logs dâ€™accÃ¨s, traÃ§abilitÃ©, alertes sur comportements suspects.

---

## RÃ©ponse type Ã  la question : "Comment sÃ©curiser une application en microservices ?"

### 1. MÃ©thodologie globale

- **Approche defense-in-depth** : superposer plusieurs couches de sÃ©curitÃ© (authentification, autorisation, rÃ©seau, monitoring, etc.).
- **Principe du moindre privilÃ¨ge** : chaque service, utilisateur ou composant nâ€™a accÃ¨s quâ€™au strict nÃ©cessaire.
- **Zero Trust** : ne jamais faire confiance par dÃ©faut, mÃªme au sein du rÃ©seau interne.
- **Automatiser la sÃ©curitÃ©** : CI/CD avec scans, tests, gestion des secrets, audit.

### 2. Ã‰tapes et bonnes pratiques

1. **Authentification centralisÃ©e**
   - Utiliser un Identity Provider (IdP) compatible OAuth2/OpenID Connect (ex : Keycloak, Auth0, Azure AD).
   - Tous les clients (front, mobile, autres services) sâ€™authentifient auprÃ¨s de lâ€™IdP.

2. **Autorisation dÃ©lÃ©guÃ©e**
   - Utiliser des tokens JWT signÃ©s pour transporter lâ€™identitÃ© et les droits (scopes, rÃ´les).
   - Chaque microservice valide le JWT (signature, expiration, scopes) avant de traiter la requÃªte.
   - RBAC (rÃ´les) ou ABAC (attributs) selon la granularitÃ© voulue.

3. **SÃ©curisation des API**
   - HTTPS obligatoire partout (TLS).
   - Rate limiting, CORS, input validation, logs dâ€™accÃ¨s, monitoring.
   - API Gateway pour centraliser la sÃ©curitÃ©, le routage, le throttling, lâ€™audit.

4. **SÃ©curitÃ© rÃ©seau**
   - Segmentation rÃ©seau (NetworkPolicy K8s, VPC, firewall).
   - Interdire les accÃ¨s directs entre services non nÃ©cessaires.
   - Mutual TLS (mTLS) pour lâ€™authentification inter-services (ex : Istio, Linkerd).

5. **Gestion des secrets**
   - Stocker les secrets dans un gestionnaire sÃ©curisÃ© (Vault, KMS, Secret Manager).
   - Jamais de secrets en dur dans le code ou les images Docker.

6. **SÃ©curitÃ© CI/CD**
   - Scanner les dÃ©pendances (SCA), les images (SAST/DAST), vÃ©rifier lâ€™absence de secrets.
   - Limiter les droits des runners, auditer les pipelines.

7. **Audit, traÃ§abilitÃ©, alertes**
   - Centraliser les logs, activer le tracing distribuÃ©, gÃ©nÃ©rer des alertes sur comportements suspects.

### 3. Technologies et protocoles recommandÃ©s

- **OAuth2 / OpenID Connect** : pour lâ€™authentification et lâ€™autorisation dÃ©lÃ©guÃ©e (SSO, tokens JWT).
- **JWT** : pour transporter lâ€™identitÃ© et les droits entre services.
- **HTTPS (TLS)** : pour chiffrer tous les Ã©changes.
- **API Gateway** : Kong, NGINX, Spring Cloud Gateway, etc.
- **mTLS** : pour lâ€™authentification forte inter-services (Istio, Linkerd).
- **Vault, KMS, Secret Manager** : gestion des secrets.
- **Kubernetes NetworkPolicy** : segmentation rÃ©seau.
- **Outils CI/CD** : SonarQube, Trivy, Snyk, GitHub Actions, GitLab CI.

### 4. SchÃ©ma mermaid : chaÃ®ne de sÃ©curitÃ© microservices

```mermaid
graph TD
  Client -->|OAuth2/OIDC| IdP[Identity Provider]
  Client -->|JWT| API_Gateway
  API_Gateway -->|JWT| ServiceA
  API_Gateway -->|JWT| ServiceB
  ServiceA -- mTLS --> ServiceB
  ServiceA -->|Vault| SecretManager
  API_Gateway -->|Logs| Monitoring
```

### 5. Astuces entretien

- Toujours citer lâ€™authentification centralisÃ©e (OAuth2/OIDC) et la validation des JWT cÃ´tÃ© microservice.
- Expliquer lâ€™intÃ©rÃªt de lâ€™API Gateway et du mTLS.
- Insister sur la gestion des secrets et la CI/CD sÃ©curisÃ©e.
- Mentionner la traÃ§abilitÃ© et lâ€™audit.
- Adapter la rÃ©ponse selon le contexte (cloud, K8s, legacy, etc.).

---

## RÃ©ponse simple et dÃ©butant Ã  : "Comment sÃ©curiser une application en microservices ?"

### Ã‰tapes claires Ã  lâ€™oral (niveau dÃ©butant)

1. **VÃ©rifier lâ€™identitÃ© de lâ€™utilisateur**
   - Utiliser un systÃ¨me de connexion centralisÃ© (ex : login via Google, Azure, Keycloak).
   - Chaque utilisateur doit sâ€™authentifier pour accÃ©der Ã  lâ€™appli.

2. **Donner les bons droits**
   - AprÃ¨s connexion, donner Ã  chaque utilisateur seulement ce quâ€™il a le droit de faire (ex : admin, user simple).
   - On utilise des rÃ´les ou des permissions.

3. **ProtÃ©ger les Ã©changes**
   - Toujours utiliser HTTPS (le cadenas dans lâ€™URL) pour que personne ne puisse lire ou modifier les donnÃ©es Ã©changÃ©es.

4. **VÃ©rifier les accÃ¨s Ã  chaque service**
   - Chaque microservice doit vÃ©rifier que la personne a le droit dâ€™accÃ©der Ã  la ressource (vÃ©rifier le token dâ€™accÃ¨s).

5. **Ne jamais mettre de mots de passe ou secrets dans le code**
   - Utiliser un coffre-fort Ã  secrets (ex : Vault, variables dâ€™environnement, fichiers protÃ©gÃ©s).

6. **Limiter les attaques**
   - Bloquer les tentatives rÃ©pÃ©tÃ©es de connexion (anti-brute force).
   - Valider toutes les donnÃ©es reÃ§ues (pour Ã©viter les failles comme lâ€™injection SQL ou XSS).

7. **Surveiller et enregistrer ce qui se passe**
   - Garder des traces (logs) de qui fait quoi, pour dÃ©tecter les comportements suspects.

### Exemple de rÃ©ponse orale (dÃ©butant)

> "Pour sÃ©curiser une appli en microservices, je commence par mettre une authentification centralisÃ©e (ex : login Google ou Keycloak), puis je donne Ã  chaque utilisateur les droits adaptÃ©s (rÃ´les). Jâ€™utilise toujours HTTPS pour chiffrer les Ã©changes. Chaque service vÃ©rifie le token dâ€™accÃ¨s avant de rÃ©pondre. Je ne mets jamais de mots de passe dans le code, jâ€™utilise un coffre-fort Ã  secrets. Je bloque les attaques simples (brute force, injection) en validant les entrÃ©es et en limitant les tentatives. Enfin, je surveille les accÃ¨s avec des logs pour dÃ©tecter les problÃ¨mes."

### Astuce entretien

- Si tu ne connais pas un mot, explique avec tes mots : "Je vÃ©rifie qui se connecte, je donne les droits, je chiffre les Ã©changes, je protÃ¨ge les mots de passe, je surveille les accÃ¨s."
- Citer un outil ou une techno connue (Keycloak, HTTPS, Vault) rassure le jury, mais lâ€™important câ€™est la logique.

---

## Exemple d'Ã©tapes concrÃ¨tes pour sÃ©curiser une appli microservices Spring Boot (dÃ©butant)

1. **Authentification centralisÃ©e**
   - Installer et configurer un Identity Provider (ex : Keycloak, Auth0, Azure AD).
   - Chaque utilisateur se connecte via ce service (login/mot de passe, Google, etc.).
   - Dans chaque microservice Spring Boot, ajouter la dÃ©pendance `spring-boot-starter-oauth2-resource-server`.
   - Configurer lâ€™URL du serveur dâ€™authentification dans `application.yml`â€¯:

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: https://mon-idp/.well-known/jwks.json
```

2. **VÃ©rification des droits (autorisation)**
   - Dans le code, utiliser les annotations Spring Security pour restreindre lâ€™accÃ¨sâ€¯:

```java
@RestController
public class AdminController {
  @PreAuthorize("hasRole('ADMIN')")
  @GetMapping("/admin")
  public String admin() { return "ok"; }
}
```

3. **HTTPS partout**
   - Configurer le reverse proxy (Nginx, API Gateway, Ingress K8s) pour forcer HTTPS.
   - (En local, pour tester, tu peux gÃ©nÃ©rer un certificat auto-signÃ© ou utiliser `spring-boot-devtools`.)

4. **Validation des entrÃ©es**
   - Utiliser les annotations de validation Spring (`@NotBlank`, `@Email`, etc.) sur les DTOs.
   - Exempleâ€¯:

```java
public class UserDto {
  @NotBlank
  @Email
  private String email;
}
```

5. **Gestion des secrets**
   - Ne jamais mettre de mot de passe ou clÃ© dans le code ou le repo.
   - Utiliser des variables dâ€™environnement, ou un gestionnaire de secrets (Vault, Secret Manager, K8s Secret).

6. **Limiter les attaques**
   - Ajouter un rate limiter (Spring Cloud Gateway, Resilience4j, ou configurer dans lâ€™API Gateway).
   - Activer CORS uniquement pour les domaines autorisÃ©s.

7. **Logs et surveillance**
   - Activer les logs dâ€™accÃ¨s et dâ€™erreur dans Spring Boot (`logging.level.org.springframework.security=DEBUG` pour debug).
   - Centraliser les logs (ELK, Loki, etc.) si possible.

### RÃ©sumÃ© oral

> "Dans mon appli Spring Boot, je configure lâ€™authentification centralisÃ©e avec OAuth2 (Keycloak), je protÃ¨ge chaque endpoint avec des rÃ´les, je force HTTPS, je valide toutes les entrÃ©es, je stocke les secrets dans un coffre-fort, je limite les requÃªtes, et je surveille les accÃ¨s avec les logs."
